# 与数据结构并列的 算法

## 循环和递归

1. 斐波那契数列
    ```java
    // 很容易想到递归的方法，但是这里面没有考虑到小于0的情况，not bug free
    public int fib(int n) {
        // 最好是n<=0
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return fib(n - 2) + fib(n - 1);
    }
    ```

    应该避免在生产环境使用递归，很容易出现溢出现象
    ```java
     public int fib2(int n) {
        int front = 1;
        int beforFront = 1;

        if (n <= 0) {
            return 0;
        }
        if (n <= 2) {
            return front;
        }
        int current = 0;
        for (int i = 3; i <= n; i++) {
            current = front + beforFront;
            beforFront = front;
            front = current;
        }
        return current;
    }
    ```
 
 ## 查找和排序

 ### 排序

 #### 快排

 1. partition函数.输入一个数组和基准index（默认最左面），将数组分为两个部分，左面都比index指向的值小，右面都比index指向的值大

 ```java
public static int partition(int arr[], int begin, int end) {
        int pov = begin;
        int povValue = arr[pov];

        int l = begin;
        int r = end;
        while(l < r){
            while(arr[r] >= povValue && l < r){
                r--;
            }
            while(arr[l] <= povValue && l < r){
                l++;
            }
            swap(arr, l, r);
        }
        // 将被看作pov的首个元素放到该返回的位置，也就是跳出循环时l=r的位置，必须保证l=r是小于等于povValue的
        // 所以whlie循环里面的第一个必须是从右侧开始，保证r指向的一定是小于povValue的。
        swap(arr, begin, r);
        return r;
    }

    public static void swap(int[] arr ,int l ,int r){
        int temp = arr[l];
        arr[l] = arr[r];
        arr[r] = temp;
    }
 ```

 2. 快排
 ```java
 public static void sort(int[] array,int lo,int hi) {
    if(lo>=hi) {
        return ;
    }
    int index=partition(array,lo,hi);
    sort(array,lo,index-1);
    sort(array,index+1,hi);
}
 ```